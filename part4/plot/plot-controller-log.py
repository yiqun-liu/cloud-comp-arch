import sys
import json

import matplotlib.pyplot as plt
import parse

# deal with the None in y
def plot_robust(ax, xs, ys, label):
    xs = [x for x, y in zip(xs, ys) if y is not None]
    ys = [y for y in ys if y is not None]

    # normalize
    if label.startswith('sys'):
        ys = [4 * y for y in ys]

    ax.plot(xs, ys, label=label, marker='o')

def main(util_file_path, measure_file_path=None):
    with open(util_file_path, 'r') as f:
        logs = json.load(f)

    if measure_file_path is not None:
        fig, axs = plt.subplots(3, 1, tight_layout=True)
        ax, ax2, ax3 = axs[0], axs[1], axs[2]
    else:
        fig, ax = plt.subplots(tight_layout=True)

    min_time = min([records[0][1] for records in logs.values()])
    max_time = max([records[-1][1] for records in logs.values()])
    # we keep the least 5 digits correct: useful for us align with mcperf logs
    # TODO cooperate mcperf information in the plot
    base_time = min_time // 100000 * 100000
    for name, records in logs.items():
        times = [r[1] - base_time for r in records]

        u5 = [r[0][2] for r in records]
#        u1 = [r[0][0] for r in records]
#        u3 = [r[0][1] for r in records]
#        u10 = [r[0][3] for r in records]

        plot_robust(ax, times, u5, label=name + '-u5')

    ax.set_ylabel('cpu usage')
    ax.set_xlabel('timestamp')
    ax.set_ylim([0, 4])

    ax.legend()

    if measure_file_path is not None:
        # draw the second figure
        logs = parse.load_measurement_logs(measure_file_path, include_target=True)
        times, actual_qps, target_qps, latency = list(), list(), list(), list()
        for interval, metrics in zip(logs['times'], logs['metrics']):
            # unit: unified to second
            t = (interval[0] + interval[1]) / 2 / 1000
            if t < min_time:
                continue
            if t > max_time:
                break
            times.append(t - base_time)
            actual_qps.append(metrics[0])
            target_qps.append(metrics[1])
            latency.append(metrics[2])

        ax2.plot(times, latency, marker='o', label='p95', color='g')
        ax2.plot([times[0], times[-1]], [2., 2.], linestyle='--',  label='SLO', color='g')
        ax2.legend()

        ax3.plot(times, actual_qps, marker='o', label='actual')
        ax3.plot(times, target_qps, marker='o', label='target')
        ax3.legend()

        ax2.set_ylabel('P95', color='g')
        ax3.set_ylabel('QPS')
        ax2.set_ylim([0, 5])
        ax3.set_ylim([0, 100000])

    plt.show()

# the only argument should be path to json file generated by controller
if __name__ == '__main__':
    if len(sys.argv) == 2:
        main(sys.argv[1])
    elif len(sys.argv) == 3:
        main(sys.argv[1], sys.argv[2])
    else:
        print('Expecting two file params: 1) json utilization log, 2) text measurement log')
